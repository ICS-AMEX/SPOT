<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>CSV Diff Viewer – 2× CSV Compare by Key</title>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <style>
    :root{
      --pink:#ffd1e8; /* changed cell/substring */
      --yellow:#fff59d; /* badges */
      --green:#e6f4ea; /* added row bg */
      --red:#fde7e9;   /* removed row bg */
      --ink:#1f2937;
      --muted:#6b7280;
      --ring:#e5e7eb;
      --primary:#0f766e;
      --bg:#fafafa;
    }
    html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    h1{font-size:20px;margin:0 0 8px}
    .toolbar{
      position:sticky;top:0;z-index:20;background:#fff;border-bottom:1px solid var(--ring);
      padding:10px 12px;display:grid;gap:8px;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));
    }
    .group{border:1px solid var(--ring);border-radius:10px;padding:10px;background:#fff}
    .group h3{margin:0 0 8px;font-size:13px;color:var(--muted);font-weight:600;text-transform:uppercase;letter-spacing:.04em}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    label{font-size:12px;color:var(--muted)}
    input[type="number"], select, button, .file{border:1px solid var(--ring);border-radius:10px;padding:8px 10px;background:#fff;font:inherit}
    button{cursor:pointer}
    button.primary{background:var(--primary);color:#fff;border-color:var(--primary)}
    .legend{position:sticky;top:92px;z-index:10;background:#fff;border-bottom:1px solid var(--ring);padding:8px 12px;display:flex;gap:12px;align-items:center}
    .chip{display:inline-flex;align-items:center;gap:6px;background:var(--yellow);padding:2px 8px;border-radius:999px;font-size:12px;color:#111;border:1px solid #e1d67b}
    .chip.pink{background:var(--pink);border-color:#f6a9c4}
    .chip.green{background:var(--green);border-color:#c9e7d2}
    .chip.red{background:var(--red);border-color:#f4b6bc}

    .issues{margin:12px;border:1px dashed #f59e0b;border-radius:10px;padding:10px;background:#fff}

    .results{padding:12px;}
    .card{border:1px solid var(--ring);border-radius:14px;margin:10px 0;background:#fff;overflow:hidden}
    .card header{display:flex;justify-content:space-between;gap:12px;align-items:center;padding:10px 12px;background:#f8fafc;border-bottom:1px solid var(--ring)}
    .key{font-weight:700}
    .badges{display:flex;flex-wrap:wrap;gap:6px}
    .body{padding:8px 0}

    .table{width:100%;border-collapse:separate;border-spacing:0}
    .table th,.table td{border-bottom:1px solid var(--ring);padding:8px 10px;vertical-align:top}
    .table th{position:relative;background:#fff;top:0;z-index:1}
    .table tr:last-child td{border-bottom:none}
    .side{white-space:nowrap;color:var(--muted);font-weight:600}

    /* changed styles */
    .changed{background:var(--pink)}
    mark.diff{background:var(--pink);padding:0 0.5px}
    .added-row{background:var(--green)}
    .removed-row{background:var(--red)}

    /* iPhone style switch */
    .switch{display:inline-flex;align-items:center;gap:8px}
    .switch input{position:absolute;opacity:0;width:0;height:0}
    .slider{position:relative;display:inline-block;width:44px;height:24px;background:#d1d5db;border-radius:999px;transition:.2s}
    .slider::after{content:"";position:absolute;left:3px;top:3px;width:18px;height:18px;background:#fff;border-radius:50%;box-shadow:0 1px 3px rgba(0,0,0,.25);transition:.2s}
    .switch input:checked + .slider{background:#34d399}
    .switch input:checked + .slider::after{transform:translateX(20px)}
    .switch label{font-size:12px;color:var(--ink)}

    /* resizer handle in header */
    .resizer{position:absolute;top:0;right:-3px;width:6px;height:100%;cursor:col-resize;user-select:none}
    .resizing{user-select:none}

    .toolbar small{color:var(--muted)}

    .pagination{display:flex;gap:8px;align-items:center;padding:8px 12px}

    .sticky-top{position:sticky;top:144px;background:#fff;z-index:5}

    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}

    /* column width grip visibility on hover */
    th:hover .resizer{background:rgba(15,118,110,.15)}
  </style>
</head>
<body>
  <div class="toolbar">
    <div class="group">
      <h3>Files</h3>
      <div class="row">
        <div>
          <label>Left / Old CSV</label><br>
          <input class="file" id="fileA" type="file" accept=".csv" />
        </div>
        <div>
          <label>Right / New CSV</label><br>
          <input class="file" id="fileB" type="file" accept=".csv" />
        </div>
      </div>
      <div class="row" style="margin-top:6px">
        <button id="demo" type="button">Load demo data</button>
      </div>
    </div>

    <div class="group">
      <h3>Key</h3>
      <div class="row">
        <div>
          <label>Primary key column index (1-based)</label><br>
          <input id="pkIndex" type="number" min="1" value="2" style="width:90px" />
        </div>
        <div class="switch">
          <input id="autoID" type="checkbox" checked>
          <span class="slider" aria-label="Auto-detect ID column"></span>
          <label for="autoID">Auto-detect key named ID</label>
        </div>
      </div>
      <small id="effectiveKey">Key: —</small>
    </div>

    <div class="group">
      <h3>Options</h3>
      <div class="row">
        <div class="switch"><input id="onlyChanged" type="checkbox" checked><span class="slider"></span><label for="onlyChanged">Show only changed rows</label></div>
        <div class="switch"><input id="trim" type="checkbox" checked><span class="slider"></span><label for="trim">Trim whitespace</label></div>
        <div class="switch"><input id="caseSensitive" type="checkbox"><span class="slider"></span><label for="caseSensitive">Case‑sensitive</label></div>
        <div class="switch"><input id="substringToggle" type="checkbox" checked><span class="slider"></span><label for="substringToggle">Highlight only differing substring</label></div>
        <div class="switch"><input id="nullEqual" type="checkbox"><span class="slider"></span><label for="nullEqual">Treat empty & null as equal</label></div>
      </div>
      <div class="row" style="margin-top:6px">
        <div>
          <label>Numeric tolerance</label><br>
          <input id="tolerance" type="number" step="0.0001" value="0" style="width:110px" />
        </div>
        <div>
          <label>Exclude columns (by header)</label><br>
          <select id="excludeCols" multiple size="4" style="min-width:220px;max-width:360px"></select>
        </div>
      </div>
    </div>

    <div class="group">
      <h3>Actions</h3>
      <div class="row">
        <button id="compare" class="primary" type="button">Compare</button>
        <button id="reset" type="button">Reset</button>
        <button id="downloadCsv" type="button">Download differences as CSV</button>
      </div>
      <div class="row" style="margin-top:6px">
        <label>Page size</label>
        <input id="pageSize" type="number" min="50" value="200" style="width:90px" />
      </div>
    </div>
  </div>

  <div class="legend">
    <span class="chip pink">Pink = changed</span>
    <span class="chip">Yellow badges = columns changed for this key</span>
    <span class="chip green">New row</span>
    <span class="chip red">Removed row</span>
  </div>

  <div id="issues" class="issues" style="display:none"></div>

  <div id="pagination" class="pagination" style="display:none">
    <button id="prev" type="button">◀ Prev</button>
    <div><span id="pageInfo">Page 1/1</span></div>
    <button id="next" type="button">Next ▶</button>
  </div>

  <div id="results" class="results"></div>

  <script>
  // ---------- State ----------
  let dataA = null; // {headers:[], rows:[[]]}
  let dataB = null;
  let headers = [];
  let columnWidths = []; // px widths shared across tables
  let diffEntries = []; // per key result objects for current compare
  let filteredKeys = []; // keys after filters/toggles
  let curPage = 1;

  const els = {
    fileA: document.getElementById('fileA'),
    fileB: document.getElementById('fileB'),
    demo: document.getElementById('demo'),
    pkIndex: document.getElementById('pkIndex'),
    autoID: document.getElementById('autoID'),
    effectiveKey: document.getElementById('effectiveKey'),
    onlyChanged: document.getElementById('onlyChanged'),
    trim: document.getElementById('trim'),
    caseSensitive: document.getElementById('caseSensitive'),
    substringToggle: document.getElementById('substringToggle'),
    nullEqual: document.getElementById('nullEqual'),
    tolerance: document.getElementById('tolerance'),
    excludeCols: document.getElementById('excludeCols'),
    compare: document.getElementById('compare'),
    reset: document.getElementById('reset'),
    downloadCsv: document.getElementById('downloadCsv'),
    issues: document.getElementById('issues'),
    results: document.getElementById('results'),
    pagination: document.getElementById('pagination'),
    prev: document.getElementById('prev'),
    next: document.getElementById('next'),
    pageInfo: document.getElementById('pageInfo'),
    pageSize: document.getElementById('pageSize'),
  };

  // ---------- Helpers ----------
  function readFile(file){
    return new Promise((resolve, reject)=>{
      Papa.parse(file, {
        header: true,
        skipEmptyLines: 'greedy',
        complete: results => resolve(results),
        error: err => reject(err)
      });
    });
  }

  function parseCsvString(str){
    return Papa.parse(str, {header:true, skipEmptyLines:'greedy'});
  }

  function normalizeRows(parsed){
    const headers = parsed.meta.fields || Object.keys(parsed.data?.[0]||{});
    const rows = (parsed.data||[]).map(obj => headers.map(h => obj[h] ?? ''));
    return {headers, rows};
  }

  function isNumeric(v){
    if (v === null || v === undefined || v === '') return false;
    const n = Number(v);
    return Number.isFinite(n);
  }

  function preprocess(val){
    let v = val == null ? '' : String(val);
    if (els.trim.checked) v = v.trim();
    if (!els.caseSensitive.checked) v = v.toLowerCase();
    return v;
  }

  function valuesEqual(a,b){
    // Treat empty & null equal
    if (els.nullEqual.checked){
      const emptyA = (a==null || a==='');
      const emptyB = (b==null || b==='');
      if (emptyA && emptyB) return true;
    }
    // numeric tolerance
    const tol = Number(els.tolerance.value||0);
    if (tol>0 && isNumeric(a) && isNumeric(b)){
      return Math.abs(Number(a)-Number(b)) <= tol;
    }
    return preprocess(a) === preprocess(b);
  }

  // substring diff: return [ {start,end} ] spans for string a that differ vs string b
  function diffSegments(a, b){
    a = String(a==null? '': a);
    b = String(b==null? '': b);
    // quick equal
    if (a === b) return [];
    // common prefix
    let p = 0;
    const len = Math.min(a.length, b.length);
    while (p < len && a[p] === b[p]) p++;
    // common suffix
    let s = 0;
    while (s < (len - p) && a[a.length - 1 - s] === b[b.length - 1 - s]) s++;
    const start = p;
    const endA = a.length - s;
    if (start >= endA) return []; // guard
    return [{start, end:endA}];
  }

  function wrapDiffHTML(text, segments){
    const s = String(text==null? '': text);
    if (!segments.length) return escapeHtml(s);
    let out = '';
    let cursor = 0;
    for (const seg of segments){
      if (cursor < seg.start) out += escapeHtml(s.slice(cursor, seg.start));
      out += '<mark class="diff">' + escapeHtml(s.slice(seg.start, seg.end)) + '</mark>';
      cursor = seg.end;
    }
    if (cursor < s.length) out += escapeHtml(s.slice(cursor));
    return out;
  }

  function escapeHtml(x){
    return String(x)
      .replace(/&/g,'&amp;')
      .replace(/</g,'&lt;')
      .replace(/>/g,'&gt;')
      .replace(/\"/g,'&quot;')
      .replace(/'/g,'&#39;');
  }

  function computeEffectiveKey(headersA, headersB){
    if (els.autoID.checked){
      const idxA = headersA.findIndex(h => String(h).trim().toLowerCase() === 'id');
      const idxB = headersB.findIndex(h => String(h).trim().toLowerCase() === 'id');
      if (idxA !== -1 && idxB !== -1 && idxA === idxB){
        els.effectiveKey.textContent = `Key: ID (column ${idxA+1})`;
        return idxA;
      }
    }
    const manual = Math.max(1, Number(els.pkIndex.value||1)) - 1;
    els.effectiveKey.textContent = `Key: column ${manual+1}`;
    return manual;
  }

  function buildIndex(rows, keyIdx){
    const map = new Map();
    const dupes = [];
    rows.forEach((r,i)=>{
      const k = r[keyIdx];
      if (map.has(k)) dupes.push({key:k, row:i});
      else map.set(k, r);
    });
    return {map, dupes};
  }

  function collectHeaders(){
    if (!dataA || !dataB) return [];
    // prefer A's headers
    const A = dataA.headers.slice();
    const B = dataB.headers.slice();
    // if different length, align by index
    if (A.length !== B.length){
      console.warn('Header length mismatch; proceeding by index');
    }
    return A.length ? A : B;
  }

  function populateExclude(headers){
    els.excludeCols.innerHTML = '';
    headers.forEach((h,idx)=>{
      const opt = document.createElement('option');
      opt.value = String(idx);
      opt.textContent = h;
      els.excludeCols.appendChild(opt);
    });
  }

  function getExcludedIdx(){
    return Array.from(els.excludeCols.selectedOptions).map(o=>Number(o.value));
  }

  // ---------- Core Compare ----------
  async function runCompare(){
    if (!dataA || !dataB){
      alert('Please load both CSVs (or click "Load demo data").');
      return;
    }
    headers = collectHeaders();
    if (!headers.length){
      alert('No headers detected. Ensure both CSVs have a header row.');
      return;
    }
    populateExclude(headers);

    const keyIdx = computeEffectiveKey(dataA.headers, dataB.headers);

    const ex = new Set(getExcludedIdx());

    const {map: mapA, dupes: dupA} = buildIndex(dataA.rows, keyIdx);
    const {map: mapB, dupes: dupB} = buildIndex(dataB.rows, keyIdx);

    const issues = [];
    if (dupA.length) issues.push(`Left/Old has ${dupA.length} duplicate keys.`);
    if (dupB.length) issues.push(`Right/New has ${dupB.length} duplicate keys.`);
    if (dataA.headers.length !== dataB.headers.length){
      issues.push('Header count differs between files. Comparing by column index.');
    }

    els.issues.style.display = issues.length ? 'block' : 'none';
    els.issues.innerHTML = issues.length ? ('<b>Issues</b><ul>' + issues.map(x=>`<li>${escapeHtml(x)}</li>`).join('') + '</ul>') : '';

    // union of keys
    const allKeys = new Set([...mapA.keys(), ...mapB.keys()]);

    diffEntries = [];

    for (const key of allKeys){
      const rowA = mapA.get(key) || null;
      const rowB = mapB.get(key) || null;
      const entry = {
        key,
        type: 'both', // 'both' | 'added' | 'removed'
        changedCols: [], // indices
        changedNames: [],
        cells: [], // per column: {a,b,equal,segmentsA,segmentsB}
        rowA, rowB
      };

      if (rowA && rowB){
        headers.forEach((h,idx)=>{
          const a = rowA[idx] ?? '';
          const b = rowB[idx] ?? '';
          let equal = ex.has(idx) ? true : valuesEqual(a,b);
          let segA = [], segB = [];
          if (!equal && els.substringToggle.checked){
            segA = diffSegments(a,b);
            segB = diffSegments(b,a);
          }
          if (!equal && !ex.has(idx)){
            entry.changedCols.push(idx);
            entry.changedNames.push(headers[idx] ?? `Col ${idx+1}`);
          }
          entry.cells.push({a,b,equal,segA,segB});
        });
      } else if (rowB && !rowA){
        entry.type = 'added';
      } else if (rowA && !rowB){
        entry.type = 'removed';
      }
      diffEntries.push(entry);
    }

    applyFiltersAndRender();
  }

  function applyFiltersAndRender(){
    const onlyChanged = els.onlyChanged.checked;

    let list = diffEntries;
    if (onlyChanged){
      list = list.filter(e => e.type !== 'both' ? true : e.changedCols.length > 0);
    }

    filteredKeys = list;
    curPage = 1;
    renderPage();
  }

  function renderPage(){
    const size = Math.max(50, Number(els.pageSize.value||200));
    const pages = Math.max(1, Math.ceil(filteredKeys.length / size));
    curPage = Math.min(curPage, pages);
    const start = (curPage-1)*size;
    const slice = filteredKeys.slice(start, start+size);

    els.pagination.style.display = pages>1 ? 'flex' : 'none';
    els.pageInfo.textContent = `Page ${curPage}/${pages} — showing ${slice.length} of ${filteredKeys.length}`;

    // Render cards
    const frag = document.createDocumentFragment();
    slice.forEach(entry => frag.appendChild(renderCard(entry)));
    els.results.innerHTML = '';
    els.results.appendChild(frag);

    // Init column widths (once)
    if (!columnWidths.length){
      columnWidths = new Array(headers.length).fill(0);
      // measure first table headers
      const ths = els.results.querySelectorAll('table thead th[data-col]');
      ths.forEach(th=>{
        const idx = Number(th.dataset.col);
        columnWidths[idx] = Math.max(120, th.getBoundingClientRect().width);
      });
    }
    applyColumnWidths();
  }

  function renderCard(entry){
    const card = document.createElement('div');
    card.className = 'card';

    const header = document.createElement('header');
    header.innerHTML = `<div class="key mono">${escapeHtml(entry.key)}</div>`;

    const badges = document.createElement('div');
    badges.className = 'badges';
    if (entry.type === 'added'){
      const b = document.createElement('span'); b.className='chip green'; b.textContent = 'New row'; badges.appendChild(b);
    } else if (entry.type === 'removed'){
      const b = document.createElement('span'); b.className='chip red'; b.textContent = 'Removed row'; badges.appendChild(b);
    } else if (entry.changedNames.length){
      entry.changedNames.forEach(name=>{
        const b = document.createElement('span'); b.className='chip'; b.textContent = name; badges.appendChild(b);
      });
    }
    header.appendChild(badges);

    const body = document.createElement('div');
    body.className = 'body';

    const table = document.createElement('table');
    table.className = 'table';

    // colgroup for shared widths
    const cg = document.createElement('colgroup');
    headers.forEach((_,idx)=>{
      const col = document.createElement('col');
      col.setAttribute('data-col', String(idx));
      cg.appendChild(col);
    });
    table.appendChild(cg);

    const thead = document.createElement('thead');
    const thr = document.createElement('tr');
    headers.forEach((h,idx)=>{
      const th = document.createElement('th');
      th.textContent = h;
      th.setAttribute('data-col', String(idx));
      // resizer
      const grip = document.createElement('div');
      grip.className = 'resizer';
      grip.addEventListener('mousedown', e=> startResize(e, idx));
      th.appendChild(grip);
      thr.appendChild(th);
    });
    thead.appendChild(thr);
    table.appendChild(thead);

    const tbody = document.createElement('tbody');

    if (entry.type === 'both'){
      // Old row
      const trA = document.createElement('tr');
      entry.cells.forEach((cell,idx)=>{
        const td = document.createElement('td');
        if (!cell.equal){
          if (els.substringToggle.checked){
            td.innerHTML = wrapDiffHTML(cell.a, cell.segA);
          } else {
            td.classList.add('changed');
            td.textContent = cell.a ?? '';
          }
        } else {
          td.textContent = cell.a ?? '';
        }
        td.setAttribute('data-col', String(idx));
        trA.appendChild(td);
      });

      // New row
      const trB = document.createElement('tr');
      entry.cells.forEach((cell,idx)=>{
        const td = document.createElement('td');
        if (!cell.equal){
          if (els.substringToggle.checked){
            td.innerHTML = wrapDiffHTML(cell.b, cell.segB);
          } else {
            td.classList.add('changed');
            td.textContent = cell.b ?? '';
          }
        } else {
          td.textContent = cell.b ?? '';
        }
        td.setAttribute('data-col', String(idx));
        trB.appendChild(td);
      });

      tbody.appendChild(trA);
      tbody.appendChild(trB);

    } else if (entry.type === 'added'){
      const trB = document.createElement('tr'); trB.className='added-row';
      headers.forEach((_,idx)=>{
        const td = document.createElement('td');
        td.textContent = entry.rowB[idx] ?? '';
        td.setAttribute('data-col', String(idx));
        trB.appendChild(td);
      });
      tbody.appendChild(trB);
    } else if (entry.type === 'removed'){
      const trA = document.createElement('tr'); trA.className='removed-row';
      headers.forEach((_,idx)=>{
        const td = document.createElement('td');
        td.textContent = entry.rowA[idx] ?? '';
        td.setAttribute('data-col', String(idx));
        trA.appendChild(td);
      });
      tbody.appendChild(trA);
    }

    table.appendChild(tbody);

    body.appendChild(table);
    card.appendChild(header);
    card.appendChild(body);
    return card;
  }

  function applyColumnWidths(){
    // apply widths to every colgroup col
    document.querySelectorAll('col[data-col]').forEach(col=>{
      const idx = Number(col.getAttribute('data-col'));
      const w = columnWidths[idx] || 140;
      col.style.width = w + 'px';
    });
  }

  // ----- Column resizing (shared widths) -----
  let resizeState = null;
  function startResize(e, idx){
    document.body.classList.add('resizing');
    const startX = e.clientX;
    const startW = columnWidths[idx] || 140;
    resizeState = {idx, startX, startW};
    window.addEventListener('mousemove', onResizing);
    window.addEventListener('mouseup', endResize);
  }
  function onResizing(e){
    if (!resizeState) return;
    const dx = e.clientX - resizeState.startX;
    columnWidths[resizeState.idx] = Math.max(80, resizeState.startW + dx);
    applyColumnWidths();
  }
  function endResize(){
    document.body.classList.remove('resizing');
    window.removeEventListener('mousemove', onResizing);
    window.removeEventListener('mouseup', endResize);
    resizeState = null;
  }

  // ---------- Download differences CSV ----------
  function downloadDiffCsv(){
    if (!diffEntries.length){ alert('Run Compare first.'); return; }
    const rows = [['key','column_name','old_value','new_value','change_type']];
    for (const e of diffEntries){
      if (e.type === 'both'){
        e.cells.forEach((c,idx)=>{
          if (!c.equal){
            rows.push([String(e.key), headers[idx]||`Col ${idx+1}`, String(c.a??''), String(c.b??''), 'modified']);
          }
        });
      } else if (e.type === 'added'){
        rows.push([String(e.key), '', '', '', 'added_row']);
      } else if (e.type === 'removed'){
        rows.push([String(e.key), '', '', '', 'removed_row']);
      }
    }
    const csv = rows.map(r=> r.map(v=> '"'+String(v).replace(/"/g,'""')+'"').join(',')).join('\n');
    const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = 'differences.csv'; document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  }

  // ---------- Demo Data ----------
  const demoA = `ID,Name,Status,Price,Notes\n1001,Widget A,Active,120,Blue version\n1002,Widget B,Active,199,Intro offer\n1003,Widget C,Paused,250,Discontinued soon\n1004,Gadget X,Active,75,`;
  const demoB = `ID,Name,Status,Price,Notes\n1001,Widget A,Active,129,Blue version v2\n1002,Widget B,Paused,199,Intro offer\n1003,Widget C,Paused,245,Discontinued soon!\n1005,Gadget Y,Active,89,New arrival`;

  async function loadDemo(){
    const pA = parseCsvString(demoA);
    const pB = parseCsvString(demoB);
    dataA = normalizeRows(pA);
    dataB = normalizeRows(pB);
    headers = collectHeaders();
    populateExclude(headers);
    // show effective key
    computeEffectiveKey(dataA.headers, dataB.headers);
    // auto compare
    await runCompare();
  }

  // ---------- Wire up ----------
  els.demo.addEventListener('click', loadDemo);
  els.compare.addEventListener('click', runCompare);
  els.onlyChanged.addEventListener('change', applyFiltersAndRender);
  els.pageSize.addEventListener('change', renderPage);
  els.prev.addEventListener('click', ()=>{ if (curPage>1){ curPage--; renderPage(); }});
  els.next.addEventListener('click', ()=>{ const pages=Math.ceil(filteredKeys.length/Math.max(50, Number(els.pageSize.value||200))); if (curPage<pages){ curPage++; renderPage(); }});
  els.downloadCsv.addEventListener('click', downloadDiffCsv);
  els.reset.addEventListener('click', ()=>{ window.location.reload(); });

  els.fileA.addEventListener('change', async (e)=>{
    if (!e.target.files?.[0]) return;
    const parsed = await readFile(e.target.files[0]);
    dataA = normalizeRows(parsed);
    headers = collectHeaders();
    populateExclude(headers);
    computeEffectiveKey(dataA.headers, dataB?dataB.headers:dataA.headers);
  });

  els.fileB.addEventListener('change', async (e)=>{
    if (!e.target.files?.[0]) return;
    const parsed = await readFile(e.target.files[0]);
    dataB = normalizeRows(parsed);
    headers = collectHeaders();
    populateExclude(headers);
    computeEffectiveKey(dataA?dataA.headers:dataB.headers, dataB.headers);
  });

  // Re-run compare if options change (and results exist)
  [els.trim, els.caseSensitive, els.substringToggle, els.nullEqual, els.tolerance, els.pkIndex, els.autoID].forEach(el=>{
    el.addEventListener('change', ()=>{ if (dataA && dataB){ runCompare(); }});
  });

  // ---------- Sanity check function for highlight spans ----------
  function __testDiffSpans(){
    const tests = [
      ['hello world','hello brave world'],
      ['Price: 120','Price: 129'],
      ['Same','Same'],
      ['','nonempty'],
      ['prefixXsuffix','prefixYsuffix']
    ];
    return tests.map(([a,b])=>({a,b,spansA:diffSegments(a,b),spansB:diffSegments(b,a)}));
  }
  window.__testDiffSpans = __testDiffSpans; // expose in console

  // initial hint
  els.effectiveKey.textContent = 'Key: — (load CSVs or demo)';
  </script>
</body>
</html>
